# **Developer Documentation**

## **Source Code**

The source code is located in the Pixhell folder located in the repository found [here](https://github.com/CS362-Team12/Pixhell/tree/main/Pixhell). Inside this folder, the folder with most of the code is the [Assets](https://github.com/CS362-Team12/Pixhell/tree/main/Pixhell/Assets) folder, which contains various folders related to sprites, animations, scenes, and scripts. This folder also contains the StreamingAssets folder, which is home to information such as play run information and item data. The other folders located in the Pixhell folder contain information related to Unity settings and are generally automatically generated by Unity.  
The documentation, weekly reports, and other general information are all located outside of the Pixhell folder and are in the source folder of the repository found [here](https://github.com/CS362-Team12/Pixhell/tree/main/). The reports are found in the “/reports” folder, and the documentation is found in the “/documentation” folder.  
In order to open the source code and test the project:

1. Download Github Desktop \- [Download GitHub Desktop | GitHub Desktop](https://desktop.github.com/download/)  
2. Clone the repository to an easily findable folder \- Use this link: [https://github.com/CS362-Team12/Pixhell.git](https://github.com/CS362-Team12/Pixhell.git)  
3. Download Unity Hub for desktop \- [Start Your Creative Projects and Download the Unity Hub | Unity](https://unity.com/download)  
4. In Projects \- click the add button \-\> Add project from disk  
5. Navigate to the Repository folder   
6. Select the Unity folder, which is the folder that has Assets, Packages, and Project Settings   
7. Download any needed updates (correct Unity version, etc)  
8. Open the Pixhell project

   

## **Tests**

Black box testing currently is done through debugging statements and console logs while playing. For instance, when getting hit as a player, the health will be displayed in the console each time the player is hit, and so comparing the values to the expected output is the test for that. Automatic white box testing is currently being implemented and will take the form of a single script with a list of tests that test old functions. Running this script will be useful between large updates to ensure no prior functionality is broken, or if it is, then identify where new issues are occurring quickly.  
Adding new tests will be simple; either adding debugging statements throughout the code to test functionality live or adding more functions to the automatic testing script.

## 

## **Items**

Assets/Scripts/Items/ and  Assets/StreamingAssets/Items/GlobalItems.csv

**Adding Items**:   
Adding items can be done through the GlobalItems.csv file, by simply adding a new row to the file. All numbers are percentage based (so 100 \= 100% increase). A sprite file location will need to be added (all of which are relative to the StreamingAssets folder) for display in the shop.  
Once items are added, they should automatically show up in the shop in the lobby (Limbo) to be purchased.

## 

## **Enemies**

Assets/Scripts/Combat/Enemies/

## Base Enemy Class:

### States:

Enemies have a state table which determines **what** actions they perform. Eventually, these states will probably be additionally overridden by certain conditions to fulfill our smarter enemy AI requirements.   
Use the following game constants to create an array of the states you want the enemy to be in.  
GameConstants: MOVING, ATTACKING, IDLING  
You can add more GameConstants and more states, just update the Enemy.cs file to include 1\. A condition checking for that state in the Update() function and 2\. A function call to a public, virtual function. This should not affect any other enemies. Then, add the constant to GameConstants.cs in the scripts folder using the next available integer. 

For example:   
states \= \[MOVING, IDLING, ATTACKING, IDLING\] will have an enemy move around, then idle, then attack, then idle again, before looping back to the start of the array. 

### Timers

Enemies have a timer table which determines **how long** they perform their actions. This should be a float for how many seconds you wish for that state to run.   
All timers are scaled with a multiplier of 0.8 to 1.2. This ensures that enemies spawned around the same time don’t perform on the exact same schedule, and adds variability to timings. If needed, a way to surpass this randomness could be added. 

Restrictions:  
The timer array should be the same length as the states array  
Any state which is ATTACKING should be of length 0: Any timer of length zero will run for exactly one frame. If you wish for the enemy to attack multiple times, or for a length of time, either add a new state, or have the enemy be in the ATTACKING state multiple times in a row.   
i.e. \[MOVING, ATTACKING, ATTACKING, IDLE\]. 

For example, using   
states \= \[MOVING, IDLING, ATTACKING, IDLING\], and   
timers \= \[ 3f, 0.75f, 0f, 0.75f\],  
Will make the enemy move for 3 seconds, idle for ¾ of a second, attack, and then idle for ¾ of a second. 